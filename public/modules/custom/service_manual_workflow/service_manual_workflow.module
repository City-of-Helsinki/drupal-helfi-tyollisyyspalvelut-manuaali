<?php

/**
 * @file
 */

use Drupal\content_moderation\Entity\ContentModerationStateInterface;
use Drupal\Core\Access\AccessResultForbidden;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\field\FieldConfigInterface;
use Drupal\service_manual_workflow\Event\ServiceModerationEvent;

/**
 * @file
 * Primary module hooks for Service manual workflow module.
 */

/**
 * Implements hook_form_alter().
 */
function service_manual_workflow_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Add popup only for service node form.
  if ($form_id === 'node_service_edit_form' || $form_id === 'node_service_form') {
    // Create custom save button for confirm dialog.
    $form['actions']['submit_popup'] = [
      '#type' => 'button',
      '#value' => t('Save'),
    ];

    // Hide submit button.
    $form['actions']['submit']['#attributes']['style'] = ['display:none'];
    // Add service-confirm library to form.
    $form['#attached']['library'][] = 'service_manual_workflow/service-confirm-js';
    // Attach module config to javascsript drupalSettings.
    $config = \Drupal::config('service_manual_workflow.popup_settings');
    $form['#attached']['drupalSettings']['service_manual_workflow']['popup_settings'] = $config->getRawData();
  }
}

/**
 * Implements hook_entity_operation().
 */
function service_manual_workflow_entity_operation(EntityInterface $entity) {
  $operations = [];
  if ($entity->getEntityTypeId() !== 'node' || $entity->bundle() !== 'service') {
    return $operations;
  }

  $access_service = \Drupal::service('service_manual_workflow.set_outdated_access');
  if ($access_service->access($entity, \Drupal::currentUser()) instanceof AccessResultForbidden) {
    return $operations;
  }

  $operations['set_outdated'] = [
    'title' => t('Set Outdated'),
    'weight' => 60,
    'url' => Url::fromRoute('service_manual_workflow.service_set_outdated_form', ['node' => $entity->id()], ['language' => $entity->language()]),
  ];

  return $operations;
}

/**
 * Implements hook_entity_insert().
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *
 * @return void
 */
function service_manual_workflow_entity_insert(EntityInterface $entity) {
  if (!$entity instanceof ContentModerationStateInterface) {
    return;
  }
  $state = $entity->moderation_state->value;
  // Service is set ready to publish from the start.
  if ($state == 'ready_to_publish') {
    $event = new ServiceModerationEvent($entity, \Drupal::currentUser());
    $transition = 'service_manual_workflow.draft.to.ready_to_publish';
    Drupal::service('event_dispatcher')->dispatch($transition, $event);
  }
}

/**
 * Implements hook_require_on_publish_is_published_alter().
 */
function service_manual_workflow_require_on_publish_is_published_alter(&$is_published, &$entity, $operation) {
  /** @var \Drupal\content_moderation\Entity\ContentModerationState $entity */
  $entity_type = $entity->getEntityType();
  if ($entity_type->id() !== 'node') {
    return;
  }

  $publish_states = ['ready_to_publish', 'published'];
  $moderation_state = $entity->moderation_state->value;
  $is_published = in_array($moderation_state, $publish_states);

  // Allow saving a service node to `ready to publish` state without filling the
  // `Specialist` fields which are required for specialist editors. The fields
  // are still required before publishing the node.
  if ($entity->bundle() === 'service' && $moderation_state === 'ready_to_publish') {
    $required_specialist_fields = [
      'field_service_req_speacialist',
      'field_guidance_to_service',
      'field_obligatoryness_freetext',
      'field_obligatoryness',
      'field_career_marking',
      'field_statements_unemployment',
      'field_statements',
      'field_service_suits_job_search',
    ];

    /** @var \Drupal\Core\Field\FieldItemListInterface $field */
    foreach ($entity->getFields() as $field) {
      $field_config = $field->getFieldDefinition();
      if (!($field_config instanceof FieldConfigInterface)) {
        continue;
      }
      if (in_array($field->getName(), $required_specialist_fields)) {
        // This setting is read at RequireOnPublish constraint's validate().
        // The entity itself is not saved, so the change is not persistent.
        // Setting the value to false means that validate() does not build
        // constraint violation.
        $field_config->setThirdPartySetting('require_on_publish', 'require_on_publish', FALSE);
      }
    }
  }
}

/**
 * Implements hook_entity_update().
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *
 * @return void
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function service_manual_workflow_entity_update(EntityInterface $entity) {
  if (!$entity instanceof ContentModerationStateInterface) {
    return;
  }
  if (empty($entity->original)) {
    return;
  }
  $previous_entity = _service_manual_workflow_entity_previous_revision($entity);
  $original_state = $previous_entity->moderation_state->value;
  $state = $entity->moderation_state->value;
  // Do not dispatch anything when state hasn't changed.
  if ($original_state == $state) {
    return;
  }
  $transition = sprintf('service_manual_workflow.%s.to.%s', $original_state, $state);
  $event = new ServiceModerationEvent($entity, \Drupal::currentUser());
  Drupal::service('event_dispatcher')->dispatch($transition, $event);
}

/**
 * Fetch previous revision for content moderation state.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *
 * @return \Drupal\Core\Entity\EntityInterface|null
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function _service_manual_workflow_entity_previous_revision(EntityInterface $entity) {
  $storage = \Drupal::entityTypeManager()->getStorage('content_moderation_state');
  $revision = $query = \Drupal::database()->select('content_moderation_state_field_revision', 'cr')
    ->fields('cr', ['revision_id'])
    ->condition('cr.id', $entity->id())
    ->condition('cr.revision_id', $entity->revision_id->value, '<')
    ->orderBy('cr.revision_id', 'DESC')
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();

  // If no previous revision is found. Return original version.
  if (empty($revision)) {
    return $entity->original;
  }

  return $storage->loadRevision($revision['revision_id']);
}
